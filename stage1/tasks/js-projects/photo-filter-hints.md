## photo-filter-hints

[Описание задания](stage1/tasks/js-projects/photo-filter.md)

В выполнении задания поможет видео курса JS30 [CSS Variables](https://youtu.be/AHLNzv13c2I), ссылка на которое приводится в материалах к заданию. В нём автор выполняет приложение, реализующее часть функциональности предлагаемого проекта. [Код приложения](https://github.com/wesbos/JavaScript30/tree/master/03%20-%20CSS%20Variables).

Предложенное автором решение можно усовершенствовать применив делегирование и отслеживая для изменения значения ползунка только одно событие `input` вместо двух событий `change` и `mousemove`.

Ниже о некоторых особенностях выполнения задания.

### input type="range"
Элемент `<input>` имеет больше 20 разных типов. Каждый из них предназначен для решения определённой задачи. В предложенном задании используется `input type="range"` - ползунок, при помощи которого удобно менять значение.

В html-коде приводится пример такого элемента:

```html
  <input type="range" name="sepia" min="0" max="100" value="0" data-sizing="%">
```

Здесь указаны минимальное, максимальное и текущее значение, а также использован data-атрибут, который указывает на размерность определяемых в `input type="range"` значений, он нам позже пригодится при написании js-кода.

Получить текущее значение `input type="range"` в js достаточно просто - это `input.value`.  Узнать, что значение изменилось, тоже не сложно, при помощи метода `addEventListener` отслеживаем событие `input` (да, немного запутанно называть одним и тем же словом и html-элемент и js-событие, ну как есть).

Для отображения значения css-фильтров, используем элемент `output`. Чтобы присвоить ему значение, указываем его как `output.value`.

О чём желательно помнить - о делегировании, то есть не навешивать слушатель на каждый ползунок, а отслеживать событие на их общем родителе.

Так как в предложенной разметке у тегов `<input>` нет классов (к такому тоже нужно быть готовыми), метод `element.matches('css')` позволит определить соответствует ли элемент, на котором произошло событие, указанному css-селектору.

### CSS Filters 
Про фильтры можно прочитать (или просто посмотреть картинки)  [здесь](https://css-tricks.com/almanac/properties/f/filter/) и [здесь](https://orangeable.com/css/filters) (эти же ссылки есть в материалах к заданию). Тем, кто предпочитает статьи на русском, про фильтры можно почитать [здесь](https://webformyself.com/filtry-v-css-razmytie-ottenki-serogo-yarkost-i-mnogo-drugix-effektov-v-css/).

Если коротко, фильтры - это красиво. В разработке они могут применяться для добавления различных эффектов, мы их используем для создания редактора фото.

### CSS-переменные
Статьи о css-переменных есть в материалах к заданию. Они удобные, и научиться их использовать полезно. Было бы хорошо потратить какое-то время и попытаться с ними разобраться, в дальнейшем это позволит ускорить разработку, избежать дублирования стилей. Одно из преимуществ css-переменных - их удобно менять через JavaScript. Благодаря им в нашем приложении вместо отдельной функции для каждого css-фильтра можем написать одну универсальную функцию для смены значения любого фильтра. Как она выглядит показано в видео курса JS30 [CSS Variables](https://youtu.be/AHLNzv13c2I). Единственное, желательно изменить функцию в связи с делегированием.

### Загрузка изображения по ссылке 
Загрузка изображения по ссылке средствами js не представляет проблем и сводится к смене ссылки на изображение, которое отображается на странице. Единственный момент, который нужно учесть, изображение вначале загружается и только потом отображается на странице. Изображение не должно загружаться на глазах пользователя отображаясь на странице по частям.

Необходимо отслеживать процесс загрузки изображения, событие `load`. Как это происходит и где используется можно посмотреть в [примере на codepen](https://codepen.io/irinainina/pen/abzwapy). 

Неодбходимо определить текущее время суток и сформировать ссылку на соответствующую коллекцию изображений. 

### Загрузка изображения c компьютера
На момент создания js работать с файловой системой не умел. Предполагалось, что это ему не понадобится. Но сейчас 2021 год, у разработчиков намного больше возможностей, и загрузка локальных файлов перестала быть проблемой.

Нам понадобится `<input type="file">` - представитель многочисленного семейства инпутов, предназначенный для загрузки файлов и объект `FileReader` предназначенный для чтения файлов.

Здесь можно увидеть [пример на codepen](https://codepen.io/irinainina/pen/WNopwQr) с загрузкой изображений с компьютера.

### Сохранение изображений на компьютер
С появлением HTML5 и до 2018 года для загрузки файлов в т.ч изображений на компьютер, достаточно было кликнуть по ссылке вида 
```html
  <a href="link_to_image" download="image.png">
```
В 2018 году усилились требования к безопасности. Ссылка для скачивания файлов осталась прежней, но добавилось условие: файл, который скачивается, должен находиться на том же ресурсе, на котором находится ссылка на его скачивание.

Но по условию задания нам необходимо загружать в приложение и сохранять фото, полученные по ссылке из внешних ресурсов. То есть нужно каким-то образом сделать чужое фото своим и получить на него внутреннюю ссылку, находящуюся на том же домене, на котором будет размещаться созданное приложение. С этой целью используем Canvas API. 

#### Отображаем изображение на canvas
С помощью Canvas API создают приложение для рисования, отображают графики, делают игры. Мы с его помощью сохраним изображение. Для этого нам необходимо отобразить изображение на canvas и получить на него ссылку.

**Пример**

В html-файле создадим элемент `canvas`
```html
  <canvas></canvas>
```
В css-файле укажем для него стили
```css
  canvas {
    border:1px solid #000;
    width: 500px;
    height: 500px;
  }
```
В js-файле напишем следующий код 
```js
  const canvas = document.querySelector('canvas');

  function drawImage() {
    const img = new Image();
    img.setAttribute('crossOrigin', 'anonymous'); 
    img.src = "https://upload.wikimedia.org/wikipedia/commons/c/c9/Зимний_пейзаж.jpg";
    img.onload = function() {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
    };  
  }
  drawImage();
```
Что происходит в функции `drawImage()` построчно
1. Мы создали изображение. 
2. Указали ему атрибуты `crossOrigin` и `anonymous`. Первый говорит о том, что изображение. которое будет отображено на canvas, получено с другого сайта, второй, что для его отображения нет необходимости авторизовываться на ресурсе, с которого оно загружается.
3. Указали ему ссылку. 
4. Дождались загрузки изображения
5. Указали, что внутренний размер canvas равен размеру изображения. 
7. Задали контекст рисования `ctx` 
8. При помощи метода `ctx.drawImage` отобразили изображение на canvas. 

[Пример кода на codepen](https://codepen.io/irinainina/pen/JjbWXgq)

**Обратите внимание**
- приведённые в примере размеры канваса искажают пропорции изображений, делают их квадратными. Подумайте, как эти размеры можно указать более корректно. Хоть возможно вы решите вообще не отображать canvas на странице, производя все манипуляции с ним скрыто от пользователя
- предложенный способ будет работать если на сайте, с которого получаем изображение,  правильно настроены заголовки, которые разрешают использовать контент сайта на других ресурсах. Если заголовки настроены неправильно (устаревший сайт, неопытные разработчики) предложенный способ не сработает. В задании будем получать изображения по ссылкам с гитхаба, для которого проблем с получением изображений нет.

#### Скачиваем изображение на компьютер
Ссылка на изображение, отрисованное на canvas
```js
  const dataURL = canvas.toDataURL("image/jpeg");
```
В [примере на codepen](https://codepen.io/rebelchris/pen/rNevrXg) приводится пример скачивания canvas как изображения на компьютер. [Статья с пояснениями к коду](https://daily-dev-tips.com/posts/vanilla-javascript-save-canvas-as-an-image/).

#### Сохранение изображения вместе с примененными фильтрами
У canvas есть фильтры. Про фильтры canvas можно почитать [здесь](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter)  
